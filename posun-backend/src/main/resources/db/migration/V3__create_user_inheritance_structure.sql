-- 1. LIMPIEZA PREVENTIVA
-- Eliminamos las tablas hijas primero (por las FK) y luego la posible tabla users vieja.
-- Usamos CASCADE para asegurarnos de que no queden constraints huérfanas.
DROP TABLE IF EXISTS user_admins CASCADE;
DROP TABLE IF EXISTS users_clients CASCADE;
DROP TABLE IF EXISTS users CASCADE;

-- 2. CREACIÓN DE LA TABLA PADRE
CREATE TABLE users (
                       id BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
                       tenant_id BIGINT NOT NULL,
                       name VARCHAR(100) NOT NULL,
                       last_name VARCHAR(100) NOT NULL,
                       phone_number VARCHAR(20) NOT NULL,
                       email VARCHAR(100) NOT NULL,
                       password_hash VARCHAR(255) NOT NULL,
                       CONSTRAINT pk_users PRIMARY KEY (id),
                       CONSTRAINT uk_users_email UNIQUE (email)
);

-- 3. CREACIÓN DE TABLAS HIJAS (Herencia JOINED)
CREATE TABLE user_admins (
                             id BIGINT NOT NULL,
                             user_position VARCHAR(30) NOT NULL,
                             active BOOLEAN NOT NULL DEFAULT TRUE,
                             CONSTRAINT pk_user_admins PRIMARY KEY (id)
);

CREATE TABLE users_clients (
                               id BIGINT NOT NULL,
                               CONSTRAINT pk_users_clients PRIMARY KEY (id)
);

-- 4. ESTABLECER INTEGRIDAD REFERENCIAL
-- Hija -> Padre (Crucial para el polimorfismo en DB)
ALTER TABLE user_admins
    ADD CONSTRAINT fk_user_admins_on_users FOREIGN KEY (id) REFERENCES users (id) ON DELETE CASCADE;

ALTER TABLE users_clients
    ADD CONSTRAINT fk_users_clients_on_users FOREIGN KEY (id) REFERENCES users (id) ON DELETE CASCADE;

-- Padre -> Tenant
ALTER TABLE users
    ADD CONSTRAINT fk_users_on_tenant FOREIGN KEY (tenant_id) REFERENCES tenants (id);

-- 5. OPTIMIZACIÓN
CREATE INDEX idx_users_email ON users(email);